import math
#import scipy.integrate
#import scipy.special
import scipy.stats
import mcerp

class vulnerability:
    '''
    Class for the DPM calculation and damage calculation for a given building type distribution and building-type vulnerability distribution of a location
    '''

    def __init__(self,gm,bt_dist,bt_prop):
        self.__gm = gm
        self.__bt_dist = bt_dist
        self.__bt_prop = bt_prop
        self.__vul_class_map = ['A','B','C','D','E','F']
        # Create Damage grade distribution for all vulnerability classes according to Giovinazzi 2005
        # gm: intensity for location
        # bt_dist: distribution of building types at location
        # bt_prop: propertiess of the different building types at the location
        self.__dg_pdf={}
        for vul_class in self.__vul_class_map:
            #Vulnerability index distribution for class
            self.__vi = self.__class2VI(vul_class)
            #damage grade PDFs for all vulnerability classes
            tmp = self.__pbeta(self.__mean_damage_grade(self.__gm,self.__vi))
            self.__dg_pdf[vul_class] = tmp

    def __class2VI(self,vul_class):
        '''
        Returns Vulnerability Index distribution according to Giovinazzi 2005 in form of a normal
        distribution where:
            mean: most likely VI
            sigma: most likely VI - greatest/least plausible VI = 0.04 for all
        '''
        #TODO: Include according to Giovinazzi 2005 Modification factors (local factors etc.)
        self.__means = {'A': 0.90, 'B': 0.74, 'C': 0.58, 'D': 0.42, 'E': 0.26 , 'F': 0.10}
        self.__sigma = 0.04

        return mcerp.N(self.__means[vul_class],self.__sigma)

    def __pbeta(self,mu_d,t=8):
        '''
        Beta distribution to define damage state probability density parameters according to Giovinazzi 2005:
        We have Damage grades 1-5 + no damage(DG 0) --> a=0 b=6
        '''
        self.__t=t
        #bounds of dg0-5
        self.__a,self.__b = 0,6
        #r,t parameters according to Giovinazzi 2005 (t=8)
        self.__r = self.__t * (0.007 * mu_d**3 - 0.0525 * mu_d**2 + 0.2875 * mu_d)
        #convert r,t to alpha,beta
        self.__alpha = self.__r
        self.__beta = self.__t - self.__alpha

        #return PDF (for one vulnerability class)
        return mcerp.Beta(self.__alpha._mcpts,self.__beta._mcpts,self.__a,self.__b)

    def __mean_damage_grade(self,I,V,Q=2.3):
        '''
        Returns damage grade for a given MMI distribution 'I' and vulnerability index distribution 'V' and ductility 'Q'(default: Q=2.3)
        '''
        return (2.5*(1+mcerp.umath.tanh((I+6.25*V-13.1)/Q)))

    def damage_bts(self):
        '''
        Return damage distributions for the different building types at the location considering their vulnerability class distributions
        '''
        bt_dmg = {}
        tmp = 0
        #each row in bt_prop corresponds to 1 bt
        for row in self.__bt_prop:
            #for each vul-class get share within bt
            for index in range(0,len(row[1])):
                #for non-zero share vul class multiply damage pdf with share
                    if row[1][index] != 0:
                        vul_class = self.__vul_class_map[index]
                        if row[0] in bt_dmg:
                            bt_dmg[row[0]] += self.__dg_pdf[vul_class]*row[1][index]
                        else:
                            bt_dmg[row[0]] = self.__dg_pdf[vul_class]*row[1][index]

        return bt_dmg

    @property
    def dg_pdf(self):
        '''
        Get damage grade PDFs for all vulnerability classes as an array of mcerp distribution [PDF(A),PDF(B),...,PDF(F)]
        '''
        return self.__dg_pdf
